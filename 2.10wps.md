# PWN入门

## [HGAME 2023 week1]test_nc
### 工具：kali虚拟机
### 思路和解题过程：
1. 去网上查看学习了一点PWN入门的基础知识，有关这个题目，打开环境之后是不能直接点击网页打开的，打开kali虚拟机后，使用nc连接其终端，连接成功后没有什么显示，只是光标处在一行空白中，发现可以输入命令ls来查看文件，然后cat一下flag文件发现就是所需要的flag。

## [SWPUCTF 2024 秋季新生赛]又是签到！？
### 看到：
- 一个apk文件
- 签到题，估计是简单脑洞
### 想到：
- 根据这个名字，多点点；
### 解决过程：
- 多点点但是pc貌似不支持点击实现这个apk文件（gpt：APK文件是Android应用程序的安装包格式，全称为Android Package Kit。它包含了应用程序的所有代码、资源、资产和清单文件，用于在Android设备上安装和运行应用。）
- 去网上查看资料，下载jadx这个apk反编译工具，打开apk文件，可以看到里面有很多的代码，查看主函数发现flag；
![](./使用jadx查看apk.png)

## [WUSTCTF 2020]level1
### 看到：
- 一个不知名文件level
- 一个output的txt输出文本，里面有一些数字

### 思路和解题：
- 还是去网上虚心学习wp，下载反汇编工具IDA pro之后，将文件拖入其中，按F5产生伪代码查看过程，这里我把他丢给了deepseek，试图查看一些分析
![](./分析伪代码.png)
```
我们需要根据题目给出的输出内容逆向计算出原始的 `flag` 文件内容。以下是详细的分析和计算过程：

---

 题目逻辑回顾
1. **文件读取**：
   - 从 `flag` 文件中读取 20 个字节到数组 `ptr` 中。
   - 数组 `ptr` 的索引从 0 到 19。

2. **处理逻辑**：
   - 遍历索引 `i` 从 1 到 19。
   - 如果 `i` 是奇数（`i & 1` 为真），则输出 `(unsigned int)(ptr[i] << i)`。
   - 如果 `i` 是偶数，则输出 `(unsigned int)(i * ptr[i])`。

3. **输出内容**：
   
   198
   232
   816
   200
   1536
   300
   6144
   984
   51200
   570
   92160
   1200
   565248
   756
   1474560
   800
   6291456
   1782
   65536000
   
 逆向计算思路
我们需要根据输出内容还原 `ptr[i]` 的值。具体步骤如下：

1. **奇数和偶数的区分**：
   - 奇数索引（`i` 为奇数）：输出是 `ptr[i] << i`。
   - 偶数索引（`i` 为偶数）：输出是 `i * ptr[i]`。

2. **还原方法**：
   - 对于奇数索引：`ptr[i] = (output) >> i`。
   - 对于偶数索引：`ptr[i] = (output) / i`。

3. **注意事项**：
   - 由于 `ptr[i]` 是一个字节（8 位），其值范围是 `0` 到 `255`。
   - 如果计算结果超出这个范围，说明题目可能有其他隐藏逻辑或需要进一步分析。

---

### 具体计算过程
我们将输出内容按顺序对应到索引 `i` 从 1 到 19，并逐个还原 `ptr[i]`。

#### 输出内容与索引对应关系
| 索引 `i` | 输出值       | 计算方式                     | 还原公式                     | 计算结果 `ptr[i]` |
|----------|--------------|------------------------------|------------------------------|-------------------|
| 1        | 198          | `ptr[1] << 1`                | `198 >> 1`                   | 99                |
| 2        | 232          | `2 * ptr[2]`                 | `232 / 2`                    | 116               |
| 3        | 816          | `ptr[3] << 3`                | `816 >> 3`                   | 102               |
| 4        | 200          | `4 * ptr[4]`                 | `200 / 4`                    | 50                |
| 5        | 1536         | `ptr[5] << 5`                | `1536 >> 5`                  | 48                |
| 6        | 300          | `6 * ptr[6]`                 | `300 / 6`                    | 50                |
| 7        | 6144         | `ptr[7] << 7`                | `6144 >> 7`                  | 48                |
| 8        | 984          | `8 * ptr[8]`                 | `984 / 8`                    | 123               |
| 9        | 51200        | `ptr[9] << 9`                | `51200 >> 9`                 | 100               |
| 10       | 570          | `10 * ptr[10]`               | `570 / 10`                   | 57                |
| 11       | 92160        | `ptr[11] << 11`              | `92160 >> 11`                | 45                |
| 12       | 1200         | `12 * ptr[12]`               | `1200 / 12`                  | 100               |
| 13       | 565248       | `ptr[13] << 13`              | `565248 >> 13`               | 69                |
| 14       | 756          | `14 * ptr[14]`               | `756 / 14`                   | 54                |
| 15       | 1474560      | `ptr[15] << 15`              | `1474560 >> 15`              | 45                |
| 16       | 800          | `16 * ptr[16]`               | `800 / 16`                   | 50                |
| 17       | 6291456      | `ptr[17] << 17`              | `6291456 >> 17`              | 48                |
| 18       | 1782         | `18 * ptr[18]`               | `1782 / 18`                  | 99                |
| 19       | 65536000     | `ptr[19] << 19`              | `65536000 >> 19`             | 125               |

---

### 还原的 `ptr` 数组
根据上述计算，`ptr` 数组的值如下（索引从 1 到 19）：

| 索引 `i` | `ptr[i]` |
|----------|----------|
| 1        | 99       |
| 2        | 116      |
| 3        | 102      |
| 4        | 50       |
| 5        | 48       |
| 6        | 50       |
| 7        | 48       |
| 8        | 123      |
| 9        | 100      |
| 10       | 57       |
| 11       | 45       |
| 12       | 100      |
| 13       | 69       |
| 14       | 54       |
| 15       | 45       |
| 16       | 50       |
| 17       | 48       |
| 18       | 99       |
| 19       | 125      |

---

### 转换为 ASCII 字符
将 `ptr[i]` 的值转换为 ASCII 字符：

| 索引 `i` | `ptr[i]` | ASCII 字符 |
|----------|----------|------------|
| 1        | 99       | 'c'        |
| 2        | 116      | 't'        |
| 3        | 102      | 'f'        |
| 4        | 50       | '2'        |
| 5        | 48       | '0'        |
| 6        | 50       | '2'        |
| 7        | 48       | '0'        |
| 8        | 123      | '{'        |
| 9        | 100      | 'd'        |
| 10       | 57       | '9'        |
| 11       | 45       | '-'        |
| 12       | 100      | 'd'        |
| 13       | 69       | 'E'        |
| 14       | 54       | '6'        |
| 15       | 45       | '-'        |
| 16       | 50       | '2'        |
| 17       | 48       | '0'        |
| 18       | 99       | 'c'        |
| 19       | 125      | '}'        |

---

### 最终结果
将 ASCII 字符按顺序拼接，得到 `flag` 文件的内容：
```
ctf2020{d9-dE6-20c}
### 思考：
- 在这里的左移右移是将十进制数字转化为二进制数字然后左移就是向左加几个0，每左移一位，相当于将该数乘以 2；右移同理，每右移一位，相当于将该数除以 2（向下取整）

## [HNCTF 2022 WEEK4]checker
